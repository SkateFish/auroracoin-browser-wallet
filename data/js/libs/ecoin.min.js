(function (f) {
  if (typeof exports === 'object' && typeof module !== 'undefined') {
    module.exports = f();
  } else if (typeof define === 'function' && define.amd) {
    define([], f);
  } else {
    var g;
    if (typeof window !== 'undefined') {
      g = window;
    } else if (typeof global !== 'undefined') {
      g = global;
    } else if (typeof self !== 'undefined') {
      g = self;
    } else {
      g = this;
    }
    g.ecoin = f();
  }
})(function () {
  var define, module, exports;
  return (function () {
    function r(e, n, t) {
      function o(i, f) {
        if (!n[i]) {
          if (!e[i]) {
            var c = 'function' == typeof require && require;
            if (!f && c) return c(i, !0);
            if (u) return u(i, !0);
            var a = new Error("Cannot find module '" + i + "'");
            throw ((a.code = 'MODULE_NOT_FOUND'), a);
          }
          var p = (n[i] = { exports: {} });
          e[i][0].call(
            p.exports,
            function (r) {
              var n = e[i][1][r];
              return o(n || r);
            },
            p,
            p.exports,
            r,
            e,
            n,
            t
          );
        }
        return n[i].exports;
      }
      for (
        var u = 'function' == typeof require && require, i = 0;
        i < t.length;
        i++
      )
        o(t[i]);
      return o;
    }
    return r;
  })()(
    {
      1: [function (require, module, exports) {}, {}],
      2: [
        function (require, module, exports) {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.

          'use strict';

          var R = typeof Reflect === 'object' ? Reflect : null;
          var ReflectApply =
            R && typeof R.apply === 'function'
              ? R.apply
              : function ReflectApply(target, receiver, args) {
                  return Function.prototype.apply.call(target, receiver, args);
                };

          var ReflectOwnKeys;
          if (R && typeof R.ownKeys === 'function') {
            ReflectOwnKeys = R.ownKeys;
          } else if (Object.getOwnPropertySymbols) {
            ReflectOwnKeys = function ReflectOwnKeys(target) {
              return Object.getOwnPropertyNames(target).concat(
                Object.getOwnPropertySymbols(target)
              );
            };
          } else {
            ReflectOwnKeys = function ReflectOwnKeys(target) {
              return Object.getOwnPropertyNames(target);
            };
          }

          function ProcessEmitWarning(warning) {
            if (console && console.warn) console.warn(warning);
          }

          var NumberIsNaN =
            Number.isNaN ||
            function NumberIsNaN(value) {
              return value !== value;
            };

          function EventEmitter() {
            EventEmitter.init.call(this);
          }
          module.exports = EventEmitter;
          module.exports.once = once;

          // Backwards-compat with node 0.10.x
          EventEmitter.EventEmitter = EventEmitter;

          EventEmitter.prototype._events = undefined;
          EventEmitter.prototype._eventsCount = 0;
          EventEmitter.prototype._maxListeners = undefined;

          // By default EventEmitters will print a warning if more than 10 listeners are
          // added to it. This is a useful default which helps finding memory leaks.
          var defaultMaxListeners = 10;

          function checkListener(listener) {
            if (typeof listener !== 'function') {
              throw new TypeError(
                'The "listener" argument must be of type Function. Received type ' +
                  typeof listener
              );
            }
          }

          Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
            enumerable: true,
            get: function () {
              return defaultMaxListeners;
            },
            set: function (arg) {
              if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
                throw new RangeError(
                  'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' +
                    arg +
                    '.'
                );
              }
              defaultMaxListeners = arg;
            },
          });

          EventEmitter.init = function () {
            if (
              this._events === undefined ||
              this._events === Object.getPrototypeOf(this)._events
            ) {
              this._events = Object.create(null);
              this._eventsCount = 0;
            }

            this._maxListeners = this._maxListeners || undefined;
          };

          // Obviously not all Emitters should be limited to 10. This function allows
          // that to be increased. Set to zero for unlimited.
          EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
            if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
              throw new RangeError(
                'The value of "n" is out of range. It must be a non-negative number. Received ' +
                  n +
                  '.'
              );
            }
            this._maxListeners = n;
            return this;
          };

          function _getMaxListeners(that) {
            if (that._maxListeners === undefined)
              return EventEmitter.defaultMaxListeners;
            return that._maxListeners;
          }

          EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
            return _getMaxListeners(this);
          };

          EventEmitter.prototype.emit = function emit(type) {
            var args = [];
            for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
            var doError = type === 'error';

            var events = this._events;
            if (events !== undefined)
              doError = doError && events.error === undefined;
            else if (!doError) return false;

            // If there is no 'error' event listener then throw.
            if (doError) {
              var er;
              if (args.length > 0) er = args[0];
              if (er instanceof Error) {
                // Note: The comments on the `throw` lines are intentional, they show
                // up in Node's output if this results in an unhandled exception.
                throw er; // Unhandled 'error' event
              }
              // At least give some kind of context to the user
              var err = new Error(
                'Unhandled error.' + (er ? ' (' + er.message + ')' : '')
              );
              err.context = er;
              throw err; // Unhandled 'error' event
            }

            var handler = events[type];

            if (handler === undefined) return false;

            if (typeof handler === 'function') {
              ReflectApply(handler, this, args);
            } else {
              var len = handler.length;
              var listeners = arrayClone(handler, len);
              for (var i = 0; i < len; ++i)
                ReflectApply(listeners[i], this, args);
            }

            return true;
          };

          function _addListener(target, type, listener, prepend) {
            var m;
            var events;
            var existing;

            checkListener(listener);

            events = target._events;
            if (events === undefined) {
              events = target._events = Object.create(null);
              target._eventsCount = 0;
            } else {
              // To avoid recursion in the case that type === "newListener"! Before
              // adding it to the listeners, first emit "newListener".
              if (events.newListener !== undefined) {
                target.emit(
                  'newListener',
                  type,
                  listener.listener ? listener.listener : listener
                );

                // Re-assign `events` because a newListener handler could have caused the
                // this._events to be assigned to a new object
                events = target._events;
              }
              existing = events[type];
            }

            if (existing === undefined) {
              // Optimize the case of one listener. Don't need the extra array object.
              existing = events[type] = listener;
              ++target._eventsCount;
            } else {
              if (typeof existing === 'function') {
                // Adding the second element, need to change to array.
                existing = events[type] = prepend
                  ? [listener, existing]
                  : [existing, listener];
                // If we've already got an array, just append.
              } else if (prepend) {
                existing.unshift(listener);
              } else {
                existing.push(listener);
              }

              // Check for listener leak
              m = _getMaxListeners(target);
              if (m > 0 && existing.length > m && !existing.warned) {
                existing.warned = true;
                // No error code for this since it is a Warning
                // eslint-disable-next-line no-restricted-syntax
                var w = new Error(
                  'Possible EventEmitter memory leak detected. ' +
                    existing.length +
                    ' ' +
                    String(type) +
                    ' listeners ' +
                    'added. Use emitter.setMaxListeners() to ' +
                    'increase limit'
                );
                w.name = 'MaxListenersExceededWarning';
                w.emitter = target;
                w.type = type;
                w.count = existing.length;
                ProcessEmitWarning(w);
              }
            }

            return target;
          }

          EventEmitter.prototype.addListener = function addListener(
            type,
            listener
          ) {
            return _addListener(this, type, listener, false);
          };

          EventEmitter.prototype.on = EventEmitter.prototype.addListener;

          EventEmitter.prototype.prependListener = function prependListener(
            type,
            listener
          ) {
            return _addListener(this, type, listener, true);
          };

          function onceWrapper() {
            if (!this.fired) {
              this.target.removeListener(this.type, this.wrapFn);
              this.fired = true;
              if (arguments.length === 0)
                return this.listener.call(this.target);
              return this.listener.apply(this.target, arguments);
            }
          }

          function _onceWrap(target, type, listener) {
            var state = {
              fired: false,
              wrapFn: undefined,
              target: target,
              type: type,
              listener: listener,
            };
            var wrapped = onceWrapper.bind(state);
            wrapped.listener = listener;
            state.wrapFn = wrapped;
            return wrapped;
          }

          EventEmitter.prototype.once = function once(type, listener) {
            checkListener(listener);
            this.on(type, _onceWrap(this, type, listener));
            return this;
          };

          EventEmitter.prototype.prependOnceListener =
            function prependOnceListener(type, listener) {
              checkListener(listener);
              this.prependListener(type, _onceWrap(this, type, listener));
              return this;
            };

          // Emits a 'removeListener' event if and only if the listener was removed.
          EventEmitter.prototype.removeListener = function removeListener(
            type,
            listener
          ) {
            var list, events, position, i, originalListener;

            checkListener(listener);

            events = this._events;
            if (events === undefined) return this;

            list = events[type];
            if (list === undefined) return this;

            if (list === listener || list.listener === listener) {
              if (--this._eventsCount === 0) this._events = Object.create(null);
              else {
                delete events[type];
                if (events.removeListener)
                  this.emit('removeListener', type, list.listener || listener);
              }
            } else if (typeof list !== 'function') {
              position = -1;

              for (i = list.length - 1; i >= 0; i--) {
                if (list[i] === listener || list[i].listener === listener) {
                  originalListener = list[i].listener;
                  position = i;
                  break;
                }
              }

              if (position < 0) return this;

              if (position === 0) list.shift();
              else {
                spliceOne(list, position);
              }

              if (list.length === 1) events[type] = list[0];

              if (events.removeListener !== undefined)
                this.emit('removeListener', type, originalListener || listener);
            }

            return this;
          };

          EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

          EventEmitter.prototype.removeAllListeners =
            function removeAllListeners(type) {
              var listeners, events, i;

              events = this._events;
              if (events === undefined) return this;

              // not listening for removeListener, no need to emit
              if (events.removeListener === undefined) {
                if (arguments.length === 0) {
                  this._events = Object.create(null);
                  this._eventsCount = 0;
                } else if (events[type] !== undefined) {
                  if (--this._eventsCount === 0)
                    this._events = Object.create(null);
                  else delete events[type];
                }
                return this;
              }

              // emit removeListener for all listeners on all events
              if (arguments.length === 0) {
                var keys = Object.keys(events);
                var key;
                for (i = 0; i < keys.length; ++i) {
                  key = keys[i];
                  if (key === 'removeListener') continue;
                  this.removeAllListeners(key);
                }
                this.removeAllListeners('removeListener');
                this._events = Object.create(null);
                this._eventsCount = 0;
                return this;
              }

              listeners = events[type];

              if (typeof listeners === 'function') {
                this.removeListener(type, listeners);
              } else if (listeners !== undefined) {
                // LIFO order
                for (i = listeners.length - 1; i >= 0; i--) {
                  this.removeListener(type, listeners[i]);
                }
              }

              return this;
            };

          function _listeners(target, type, unwrap) {
            var events = target._events;

            if (events === undefined) return [];

            var evlistener = events[type];
            if (evlistener === undefined) return [];

            if (typeof evlistener === 'function')
              return unwrap
                ? [evlistener.listener || evlistener]
                : [evlistener];

            return unwrap
              ? unwrapListeners(evlistener)
              : arrayClone(evlistener, evlistener.length);
          }

          EventEmitter.prototype.listeners = function listeners(type) {
            return _listeners(this, type, true);
          };

          EventEmitter.prototype.rawListeners = function rawListeners(type) {
            return _listeners(this, type, false);
          };

          EventEmitter.listenerCount = function (emitter, type) {
            if (typeof emitter.listenerCount === 'function') {
              return emitter.listenerCount(type);
            } else {
              return listenerCount.call(emitter, type);
            }
          };

          EventEmitter.prototype.listenerCount = listenerCount;
          function listenerCount(type) {
            var events = this._events;

            if (events !== undefined) {
              var evlistener = events[type];

              if (typeof evlistener === 'function') {
                return 1;
              } else if (evlistener !== undefined) {
                return evlistener.length;
              }
            }

            return 0;
          }

          EventEmitter.prototype.eventNames = function eventNames() {
            return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
          };

          function arrayClone(arr, n) {
            var copy = new Array(n);
            for (var i = 0; i < n; ++i) copy[i] = arr[i];
            return copy;
          }

          function spliceOne(list, index) {
            for (; index + 1 < list.length; index++)
              list[index] = list[index + 1];
            list.pop();
          }

          function unwrapListeners(arr) {
            var ret = new Array(arr.length);
            for (var i = 0; i < ret.length; ++i) {
              ret[i] = arr[i].listener || arr[i];
            }
            return ret;
          }

          function once(emitter, name) {
            return new Promise(function (resolve, reject) {
              function eventListener() {
                if (errorListener !== undefined) {
                  emitter.removeListener('error', errorListener);
                }
                resolve([].slice.call(arguments));
              }
              var errorListener;

              // Adding an error listener is not optional because
              // if an error is thrown on an event emitter we cannot
              // guarantee that the actual event we are waiting will
              // be fired. The result could be a silent way to create
              // memory or file descriptor leaks, which is something
              // we should avoid.
              if (name !== 'error') {
                errorListener = function errorListener(err) {
                  emitter.removeListener(name, eventListener);
                  reject(err);
                };

                emitter.once('error', errorListener);
              }

              emitter.once(name, eventListener);
            });
          }
        },
        {},
      ],
      3: [
        function (require, module, exports) {
          const ElectrumClient = require('@eCoinCore/electrum-client-js');
          const MINUTES = 60000;

          //     {"host": "lenoir.ecoincore.com", "ssl": 12343, "tcp": 12342 },
          //    {"host": "electrumx.aur.ewmcx.info", "ssl": 50002, "tcp": 50001 },
          //    {"host": "failover.aur.ewmcx.biz", "ssl": 50002, "tcp": 50001 }

          const aurmain = async () => {
            try {
              const electrum = new ElectrumClient(
                'failover.aur.ewmcx.biz',
                50003,
                'wss'
              );

              electrum.subscribe.on('blockchain.headers.subscribe', (blob) => {
                console.log(blob);
              });

              electrum.subscribe.on(
                'blockchain.scripthash.subscribe',
                (blob) => {
                  console.log(blob);
                }
              );

              await electrum.connect();

              // const serverfeatures = await electrum.server_features()
              // console.log('Server Features:', serverfeatures)

              const header = await electrum.blockchain_headers_subscribe();
              console.log('Latest header:', header);

              const scripthashStatus =
                await electrum.blockchain_scripthash_subscribe(
                  'bc7933285df62d471adc8bbff533d7335f37b4e6c206a4bf445b5acde7b65709'
                );
              console.log('Latest scripthash status:', scripthashStatus);

              const scripthashBalance =
                await electrum.blockchain_scripthash_getBalance(
                  'bc7933285df62d471adc8bbff533d7335f37b4e6c206a4bf445b5acde7b65709'
                );
              console.log('Latest scripthash status:', scripthashBalance);

              console.log('Waiting for notifications...');

              // Keep connection alive.
              setInterval(async () => {
                await electrum.server_ping();
              }, 8 * MINUTES);
            } catch (error) {
              console.error({ error });
            }
          };

          module.exports = {
            ElectrumClient,
            aurmain,
          };
        },
        { '@eCoinCore/electrum-client-js': 4 },
      ],
      4: [
        function (require, module, exports) {
          const ElectrumClient = require('./src/electrum/client');

          module.exports = ElectrumClient;
        },
        { './src/electrum/client': 5 },
      ],
      5: [
        function (require, module, exports) {
          const SocketClient = require('../socket/socket_client');
          const util = require('./util');

          const keepAliveInterval = 120 * 1000; // 2 minutes

          class ElectrumClient extends SocketClient {
            constructor(host, port, protocol, options) {
              super(host, port, protocol, options);
            }

            async connect(
              clientName,
              electrumProtocolVersion,
              persistencePolicy = { maxRetry: 10, callback: null }
            ) {
              this.persistencePolicy = persistencePolicy;

              this.timeLastCall = 0;

              if (this.status === 0) {
                try {
                  // Connect to Electrum Server.
                  await super.connect();

                  // Get banner.
                  const banner = await this.server_banner();
                  console.log(banner);

                  // Negotiate protocol version.
                  if (clientName && electrumProtocolVersion) {
                    const version = await this.server_version(
                      clientName,
                      electrumProtocolVersion
                    );
                    console.log(`Negotiated version: [${version}]`);
                  }
                } catch (err) {
                  throw new Error(
                    `failed to connect to electrum server: [${err}]`
                  );
                }

                this.keepAlive();
              }
            }

            async request(method, params) {
              if (this.status === 0) {
                throw new Error('connection not established');
              }

              this.timeLastCall = new Date().getTime();

              const response = new Promise((resolve, reject) => {
                const id = ++this.id;

                const content = util.makeRequest(method, params, id);

                this.callback_message_queue[id] = util.createPromiseResult(
                  resolve,
                  reject
                );

                this.client.send(content + '\n');
              });

              return await response;
            }

            /**
             * Ping the server to ensure it is responding, and to keep the session alive.
             * The server may disconnect clients that have sent no requests for roughly 10
             * minutes. It sends a ping request every 2 minutes. If the request fails it
             * logs an error and closes the connection.
             */
            async keepAlive() {
              if (this.status !== 0) {
                this.keepAliveHandle = setInterval(
                  async (client) => {
                    if (
                      this.timeLastCall !== 0 &&
                      new Date().getTime() >
                        this.timeLastCall + keepAliveInterval / 2
                    ) {
                      await client.server_ping().catch((err) => {
                        console.error(`ping to server failed: [${err}]`);
                        client.close(); // TODO: we should reconnect
                      });
                    }
                  },
                  keepAliveInterval,
                  this // pass this context as an argument to function
                );
              }
            }

            close() {
              return super.close();
            }

            onClose() {
              super.onClose();

              const list = [
                'server.peers.subscribe',
                'blockchain.numblocks.subscribe',
                'blockchain.headers.subscribe',
                'blockchain.address.subscribe',
              ];

              // TODO: We should probably leave listeners if the have persistency policy.
              list.forEach((event) => this.subscribe.removeAllListeners(event));

              // Stop keep alive.
              clearInterval(this.keepAliveHandle);

              // TODO: Refactor persistency
              // if (this.persistencePolicy) {
              //   if (this.persistencePolicy.maxRetry > 0) {
              //     this.reconnect();
              //     this.persistencePolicy.maxRetry -= 1;
              //   } else if (this.persistencePolicy.callback != null) {
              //     this.persistencePolicy.callback();
              //   }
              // }
            }

            // TODO: Refactor persistency
            // reconnect() {
            //   return this.initElectrum(this.electrumConfig);
            // }

            // ElectrumX API
            //
            // Documentation:
            // https://electrumx.readthedocs.io/en/latest/protocol-methods.html
            //
            server_version(client_name, protocol_version) {
              return this.request('server.version', [
                client_name,
                protocol_version,
              ]);
            }
            server_banner() {
              return this.request('server.banner', []);
            }
            server_ping() {
              return this.request('server.ping', []);
            }
            server_addPeer(features) {
              return this.request('server.add_peer', [features]);
            }
            server_donation_address() {
              return this.request('server.donation_address', []);
            }
            server_features() {
              return this.request('server.features', []);
            }
            server_peers_subscribe() {
              return this.request('server.peers.subscribe', []);
            }
            blockchain_address_getProof(address) {
              return this.request('blockchain.address.get_proof', [address]);
            }
            blockchain_scripthash_getBalance(scripthash) {
              return this.request('blockchain.scripthash.get_balance', [
                scripthash,
              ]);
            }
            blockchain_scripthash_getHistory(scripthash) {
              return this.request('blockchain.scripthash.get_history', [
                scripthash,
              ]);
            }
            blockchain_scripthash_getMempool(scripthash) {
              return this.request('blockchain.scripthash.get_mempool', [
                scripthash,
              ]);
            }
            blockchain_scripthash_listunspent(scripthash) {
              return this.request('blockchain.scripthash.listunspent', [
                scripthash,
              ]);
            }
            blockchain_scripthash_subscribe(scripthash) {
              return this.request('blockchain.scripthash.subscribe', [
                scripthash,
              ]);
            }
            blockchain_scripthash_unsubscribe(scripthash) {
              return this.request('blockchain.scripthash.unsubscribe', [
                scripthash,
              ]);
            }
            blockchain_block_header(height, cpHeight = 0) {
              return this.request('blockchain.block.header', [
                height,
                cpHeight,
              ]);
            }
            blockchain_block_headers(startHeight, count, cpHeight = 0) {
              return this.request('blockchain.block.headers', [
                startHeight,
                count,
                cpHeight,
              ]);
            }
            blockchainEstimatefee(number) {
              return this.request('blockchain.estimatefee', [number]);
            }
            blockchain_headers_subscribe() {
              return this.request('blockchain.headers.subscribe', []);
            }
            blockchain_relayfee() {
              return this.request('blockchain.relayfee', []);
            }
            blockchain_transaction_broadcast(rawtx) {
              return this.request('blockchain.transaction.broadcast', [rawtx]);
            }
            blockchain_transaction_get(tx_hash, verbose) {
              return this.request('blockchain.transaction.get', [
                tx_hash,
                verbose ? verbose : false,
              ]);
            }
            blockchain_transaction_getMerkle(tx_hash, height) {
              return this.request('blockchain.transaction.get_merkle', [
                tx_hash,
                height,
              ]);
            }
            mempool_getFeeHistogram() {
              return this.request('mempool.get_fee_histogram', []);
            }
            // ---------------------------------
            // protocol 1.1 deprecated method
            // ---------------------------------
            blockchain_utxo_getAddress(tx_hash, index) {
              return this.request('blockchain.utxo.get_address', [
                tx_hash,
                index,
              ]);
            }
            blockchain_numblocks_subscribe() {
              return this.request('blockchain.numblocks.subscribe', []);
            }
            // ---------------------------------
            // protocol 1.2 deprecated method
            // ---------------------------------
            blockchain_block_getChunk(index) {
              return this.request('blockchain.block.get_chunk', [index]);
            }
            blockchain_address_getBalance(address) {
              return this.request('blockchain.address.get_balance', [address]);
            }
            blockchain_address_getHistory(address) {
              return this.request('blockchain.address.get_history', [address]);
            }
            blockchain_address_getMempool(address) {
              return this.request('blockchain.address.get_mempool', [address]);
            }
            blockchain_address_listunspent(address) {
              return this.request('blockchain.address.listunspent', [address]);
            }
            blockchain_address_subscribe(address) {
              return this.request('blockchain.address.subscribe', [address]);
            }
          }

          module.exports = ElectrumClient;
        },
        { '../socket/socket_client': 7, './util': 6 },
      ],
      6: [
        function (require, module, exports) {
          function makeRequest(method, params, id) {
            return JSON.stringify({
              jsonrpc: '2.0',
              method: method,
              params: params,
              id: id,
            });
          }

          function createPromiseResult(resolve, reject) {
            return (err, result) => {
              if (err) reject(err);
              else resolve(result);
            };
          }

          module.exports = {
            makeRequest,
            createPromiseResult,
          };
        },
        {},
      ],
      7: [
        function (require, module, exports) {
          const EventEmitter = require('events').EventEmitter;
          const util = require('./util');

          const TCPSocketClient = require('./socket_client_tcp');
          const WebSocketClient = require('./socket_client_ws');

          class SocketClient {
            constructor(host, port, protocol, options) {
              this.id = 0;
              this.host = host;
              this.port = port;
              this.protocol = protocol;
              this.options = options;
              this.status = 0;
              this.callback_message_queue = {};
              this.subscribe = new EventEmitter();
              this.mp = new util.MessageParser((body, n) => {
                this.onMessage(body, n);
              });

              switch (protocol) {
                case 'tcp':
                case 'tls':
                case 'ssl':
                  this.client = new TCPSocketClient(
                    this,
                    host,
                    port,
                    protocol,
                    options
                  );
                  break;
                case 'ws':
                case 'wss':
                  this.client = new WebSocketClient(
                    this,
                    host,
                    port,
                    protocol,
                    options
                  );
                  break;
                default:
                  throw new Error(`invalid protocol: [${protocol}]`);
              }
            }

            async connect() {
              if (this.status === 1) {
                return Promise.resolve();
              }

              this.status = 1;
              return this.client.connect();
            }

            close() {
              if (this.status === 0) {
                return;
              }

              this.client.close();

              this.status = 0;
            }

            response(msg) {
              const callback = this.callback_message_queue[msg.id];

              if (callback) {
                delete this.callback_message_queue[msg.id];
                if (msg.error) {
                  callback(msg.error.message);
                } else {
                  callback(null, msg.result);
                }
              } else {
                console.log("Can't get callback");
              }
            }

            onMessage(body, n) {
              const msg = JSON.parse(body);
              if (msg instanceof Array) {
                // don't support batch request
              } else {
                if (msg.id !== void 0) {
                  this.response(msg);
                } else {
                  this.subscribe.emit(msg.method, msg.params);
                }
              }
            }

            onConnect() {}

            onClose(event) {
              this.status = 0;
              Object.keys(this.callback_message_queue).forEach((key) => {
                this.callback_message_queue[key](new Error('close connect'));
                delete this.callback_message_queue[key];
              });
            }

            onRecv(chunk) {
              this.mp.run(chunk);
            }

            onEnd(error) {
              console.log(`onEnd: [${error}]`);
            }

            onError(error) {
              console.log(`onError: [${error}]`);
            }
          }

          module.exports = SocketClient;
        },
        {
          './socket_client_tcp': 8,
          './socket_client_ws': 9,
          './util': 10,
          events: 2,
        },
      ],
      8: [
        function (require, module, exports) {
          'use strict';
          const net = require('net');

          const TIMEOUT = 10000;

          class SocketClient {
            constructor(self, host, port, protocol, options) {
              let conn;
              switch (protocol) {
                case 'tcp':
                  conn = new net.Socket();
                  break;
                case 'tls':
                case 'ssl':
                  let tls;
                  try {
                    tls = require('tls');
                  } catch (e) {
                    throw new Error('tls package could not be loaded');
                  }
                  conn = new tls.TLSSocket(options);
                  break;
                default:
                  throw new Error('not supported protocol', protocol);
              }
              this.host = host;
              this.port = port;
              initialize(self, conn);
              this.client = conn;
            }

            async connect() {
              const client = this.client;

              return new Promise((resolve, reject) => {
                const errorHandler = (e) => reject(e);
                client.connect(this.port, this.host, () => {
                  client.removeListener('error', errorHandler);
                  resolve();
                });
                client.on('error', errorHandler);
              });
            }

            async close() {
              this.client.end();
              this.client.destroy();
            }

            send(data) {
              this.client.write(data);
            }
          }

          function initialize(self, conn) {
            conn.setTimeout(TIMEOUT);
            conn.setEncoding('utf8');
            conn.setKeepAlive(true, 0);
            conn.setNoDelay(true);

            conn.on('connect', () => {
              conn.setTimeout(0);
              self.onConnect();
            });

            conn.on('close', (e) => {
              self.onClose(e);
            });

            conn.on('timeout', () => {
              const e = new Error('ETIMEDOUT');
              e.errorno = 'ETIMEDOUT';
              e.code = 'ETIMEDOUT';
              e.connect = false;
              conn.emit('error', e);
            });

            conn.on('data', (chunk) => {
              conn.setTimeout(0);
              self.onRecv(chunk);
            });

            conn.on('end', (e) => {
              conn.setTimeout(0);
              self.onEnd(e);
            });

            conn.on('error', (e) => {
              self.onError(e);
            });
          }

          module.exports = SocketClient;
        },
        { net: 1, tls: 1 },
      ],
      9: [
        function (require, module, exports) {
          'use strict';
          const W3CWebSocket = require('websocket').w3cwebsocket;

          class WebSocketClient {
            constructor(self, host, port, protocol, options) {
              this.self = self;
              this.host = host;
              this.port = port;
              this.protocol = protocol;
              this.options = options;
              this.client = null;
            }

            async connect() {
              const url = `${this.protocol}://${this.host}:${this.port}`;

              // TODO: Add docs
              // https://github.com/theturtle32/WebSocket-Node/blob/master/docs/W3CWebSocket.md#constructor
              const client = new W3CWebSocket(
                url,
                undefined,
                undefined,
                undefined,
                this.options
              );

              this.client = client;

              return new Promise((resolve, reject) => {
                client.onerror = (error) => {
                  this.self.onError(error);
                };

                client.onclose = (event) => {
                  this.self.onClose(event);
                  reject(
                    new Error(
                      `websocket connection closed: code: [${event.code}], reason: [${event.reason}]`
                    )
                  );
                };

                client.onmessage = (message) => {
                  this.self.onMessage(message.data);
                };

                client.onopen = () => {
                  if (client.readyState === client.OPEN) {
                    this.self.onConnect();
                    resolve();
                  }
                };
              });
            }

            async close() {
              this.client.close(1000, 'close connection');
            }

            // string
            send(data) {
              this.client.send(data);
            }
          }

          module.exports = WebSocketClient;
        },
        { websocket: 12 },
      ],
      10: [
        function (require, module, exports) {
          function createRecursiveParser(max_depth, delimiter) {
            const MAX_DEPTH = max_depth;
            const DELIMITER = delimiter;

            const recursiveParser = (n, buffer, callback) => {
              if (buffer.length === 0) {
                return { code: 0, buffer: buffer };
              }
              if (n > MAX_DEPTH) {
                return { code: 1, buffer: buffer };
              }
              const xs = buffer.split(DELIMITER);
              if (xs.length === 1) {
                return { code: 0, buffer: buffer };
              }
              callback(xs.shift(), n);
              return recursiveParser(n + 1, xs.join(DELIMITER), callback);
            };
            return recursiveParser;
          }

          class MessageParser {
            constructor(callback) {
              this.buffer = '';
              this.callback = callback;
              this.recursiveParser = createRecursiveParser(20, '\n');
            }

            run(chunk) {
              this.buffer += chunk;
              while (true) {
                const res = this.recursiveParser(0, this.buffer, this.callback);
                this.buffer = res.buffer;
                if (res.code === 0) {
                  break;
                }
              }
            }
          }

          exports.MessageParser = MessageParser;
        },
        {},
      ],
      11: [
        function (require, module, exports) {
          var naiveFallback = function () {
            if (typeof self === 'object' && self) return self;
            if (typeof window === 'object' && window) return window;
            throw new Error('Unable to resolve global `this`');
          };

          module.exports = (function () {
            if (this) return this;

            // Unexpected strict mode (may happen if e.g. bundled into ESM module)

            // Fallback to standard globalThis if available
            if (typeof globalThis === 'object' && globalThis) return globalThis;

            // Thanks @mathiasbynens -> https://mathiasbynens.be/notes/globalthis
            // In all ES5+ engines global object inherits from Object.prototype
            // (if you approached one that doesn't please report)
            try {
              Object.defineProperty(Object.prototype, '__global__', {
                get: function () {
                  return this;
                },
                configurable: true,
              });
            } catch (error) {
              // Unfortunate case of updates to Object.prototype being restricted
              // via preventExtensions, seal or freeze
              return naiveFallback();
            }
            try {
              // Safari case (window.__global__ works, but __global__ does not)
              if (!__global__) return naiveFallback();
              return __global__;
            } finally {
              delete Object.prototype.__global__;
            }
          })();
        },
        {},
      ],
      12: [
        function (require, module, exports) {
          var _globalThis;
          if (typeof globalThis === 'object') {
            _globalThis = globalThis;
          } else {
            try {
              _globalThis = require('es5-ext/global');
            } catch (error) {
            } finally {
              if (!_globalThis && typeof window !== 'undefined') {
                _globalThis = window;
              }
              if (!_globalThis) {
                throw new Error('Could not determine global this');
              }
            }
          }

          var NativeWebSocket =
            _globalThis.WebSocket || _globalThis.MozWebSocket;
          var websocket_version = require('./version');

          /**
           * Expose a W3C WebSocket class with just one or two arguments.
           */
          function W3CWebSocket(uri, protocols) {
            var native_instance;

            if (protocols) {
              native_instance = new NativeWebSocket(uri, protocols);
            } else {
              native_instance = new NativeWebSocket(uri);
            }

            /**
             * 'native_instance' is an instance of nativeWebSocket (the browser's WebSocket
             * class). Since it is an Object it will be returned as it is when creating an
             * instance of W3CWebSocket via 'new W3CWebSocket()'.
             *
             * ECMAScript 5: http://bclary.com/2004/11/07/#a-13.2.2
             */
            return native_instance;
          }
          if (NativeWebSocket) {
            ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'].forEach(function (
              prop
            ) {
              Object.defineProperty(W3CWebSocket, prop, {
                get: function () {
                  return NativeWebSocket[prop];
                },
              });
            });
          }

          /**
           * Module exports.
           */
          module.exports = {
            w3cwebsocket: NativeWebSocket ? W3CWebSocket : null,
            version: websocket_version,
          };
        },
        { './version': 13, 'es5-ext/global': 11 },
      ],
      13: [
        function (require, module, exports) {
          module.exports = require('../package.json').version;
        },
        { '../package.json': 14 },
      ],
      14: [
        function (require, module, exports) {
          module.exports = {
            _from: 'websocket@^1.0.29',
            _id: 'websocket@1.0.34',
            _inBundle: false,
            _integrity:
              'sha512-PRDso2sGwF6kM75QykIesBijKSVceR6jL2G8NGYyq2XrItNC2P5/qL5XeR056GhA+Ly7JMFvJb9I312mJfmqnQ==',
            _location: '/websocket',
            _phantomChildren: {},
            _requested: {
              type: 'range',
              registry: true,
              raw: 'websocket@^1.0.29',
              name: 'websocket',
              escapedName: 'websocket',
              rawSpec: '^1.0.29',
              saveSpec: null,
              fetchSpec: '^1.0.29',
            },
            _requiredBy: ['/@eCoinCore/electrum-client-js'],
            _resolved:
              'https://registry.npmjs.org/websocket/-/websocket-1.0.34.tgz',
            _shasum: '2bdc2602c08bf2c82253b730655c0ef7dcab3111',
            _spec: 'websocket@^1.0.29',
            _where:
              'G:\\dev\\test\\node\\ecoin\\node_modules\\@eCoinCore\\electrum-client-js',
            author: {
              name: 'Brian McKelvey',
              email: 'theturtle32@gmail.com',
              url: 'https://github.com/theturtle32',
            },
            browser: 'lib/browser.js',
            bugs: {
              url: 'https://github.com/theturtle32/WebSocket-Node/issues',
            },
            bundleDependencies: false,
            config: {
              verbose: false,
            },
            contributors: [
              {
                name: 'Iñaki Baz Castillo',
                email: 'ibc@aliax.net',
                url: 'http://dev.sipdoc.net',
              },
            ],
            dependencies: {
              bufferutil: '^4.0.1',
              debug: '^2.2.0',
              'es5-ext': '^0.10.50',
              'typedarray-to-buffer': '^3.1.5',
              'utf-8-validate': '^5.0.2',
              yaeti: '^0.0.6',
            },
            deprecated: false,
            description:
              'Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.',
            devDependencies: {
              'buffer-equal': '^1.0.0',
              gulp: '^4.0.2',
              'gulp-jshint': '^2.0.4',
              jshint: '^2.0.0',
              'jshint-stylish': '^2.2.1',
              tape: '^4.9.1',
            },
            directories: {
              lib: './lib',
            },
            engines: {
              node: '>=4.0.0',
            },
            homepage: 'https://github.com/theturtle32/WebSocket-Node',
            keywords: [
              'websocket',
              'websockets',
              'socket',
              'networking',
              'comet',
              'push',
              'RFC-6455',
              'realtime',
              'server',
              'client',
            ],
            license: 'Apache-2.0',
            main: 'index',
            name: 'websocket',
            repository: {
              type: 'git',
              url: 'git+https://github.com/theturtle32/WebSocket-Node.git',
            },
            scripts: {
              gulp: 'gulp',
              test: 'tape test/unit/*.js',
            },
            version: '1.0.34',
          };
        },
        {},
      ],
    },
    {},
    [3]
  )(3);
});
